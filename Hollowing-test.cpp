#include <fstream>
#include <iostream>
#include <windows.h>
#include <cstdio>
#include <tchar.h>
#include <psapi.h>
#include <winternl.h>
#include <strsafe.h>
#include <dbghelp.h>
#include <Memoryapi.h>


typedef NTSTATUS(__stdcall *Q_process)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass,
                                       PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

typedef PIMAGE_NT_HEADERS(__stdcall *ImageNtHead)(PVOID base);

void debugBs(LPTSTR lpszFunction) {
    // Retrieve the system error message for the last-error code


    LPVOID lpMsgBuf;
    LPVOID lpDisplayBuf;
    DWORD dw = GetLastError();

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dw,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf, 0, NULL);

    // Display the error message and exit the process

    lpDisplayBuf = (LPVOID) LocalAlloc(LMEM_ZEROINIT,
                                       (lstrlen((LPCTSTR) lpMsgBuf) + lstrlen((LPCTSTR) lpszFunction) + 40) *
                                       sizeof(TCHAR));
    StringCchPrintf((LPTSTR) lpDisplayBuf, LocalSize(lpDisplayBuf) / sizeof(TCHAR), TEXT("%s failed with error %d: %s"),
                    lpszFunction, dw, lpMsgBuf);
    MessageBox(NULL, (LPCTSTR) lpDisplayBuf, TEXT("Error"), MB_OK);

    LocalFree(lpMsgBuf);
    LocalFree(lpDisplayBuf);
}

void ShowProcessIntegrityLevel(HANDLE hProcess) {
    HANDLE hToken;

    DWORD dwLengthNeeded;
    DWORD dwError = ERROR_SUCCESS;

    PTOKEN_MANDATORY_LABEL pTIL = NULL;
    LPWSTR pStringSid;
    DWORD dwIntegrityLevel;

    if (OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_QUERY_SOURCE, &hToken)) {
        // Get the Integrity level.
        if (!GetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &dwLengthNeeded)) {
            dwError = GetLastError();
            if (dwError == ERROR_INSUFFICIENT_BUFFER) {
                pTIL = (PTOKEN_MANDATORY_LABEL) LocalAlloc(0, dwLengthNeeded);
                if (pTIL != NULL) {
                    if (GetTokenInformation(hToken, TokenIntegrityLevel, pTIL, dwLengthNeeded, &dwLengthNeeded)) {
                        dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid, (DWORD) (UCHAR) (
                                *GetSidSubAuthorityCount(pTIL->Label.Sid) - 1));

                        if (dwIntegrityLevel < SECURITY_MANDATORY_MEDIUM_RID) {
                            // Low Integrity
                            wprintf(L"Low Process");
                        } else if (dwIntegrityLevel >= SECURITY_MANDATORY_MEDIUM_RID &&
                                   dwIntegrityLevel < SECURITY_MANDATORY_HIGH_RID) {
                            // Medium Integrity
                            wprintf(L"Medium Process");
                        } else if (dwIntegrityLevel >= SECURITY_MANDATORY_HIGH_RID &&
                                   dwIntegrityLevel < SECURITY_MANDATORY_SYSTEM_RID) {

                            wprintf(L"High Process");
                        } else if (dwIntegrityLevel >= SECURITY_MANDATORY_SYSTEM_RID) {
                            // Medium Integrity
                            wprintf(L"System Process");
                        }
                    }
                    LocalFree(pTIL);
                }
            }
        }
        CloseHandle(hToken);
    }
}


void PrintProcessNameAndID(DWORD processID) {
    TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

    // Get a handle to the process.

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);

    // Get the process name.

    if (NULL != hProcess) {
        HMODULE hMod;
        DWORD cbNeeded;

        if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
            GetModuleBaseName(hProcess, hMod, szProcessName, sizeof(szProcessName) / sizeof(TCHAR));
        }
    }

    // Print the process name and identifier.

    _tprintf(TEXT("%s  (PID: %u) "), szProcessName, processID);
    ShowProcessIntegrityLevel(hProcess);
    wprintf(L"\n");


    // Release the handle to the process.

    CloseHandle(hProcess);
}

int main() {
    PROCESS_INFORMATION processInformation = PROCESS_INFORMATION();
    STARTUPINFO startupinfo = STARTUPINFO();

    CreateProcessA(nullptr, "c:\\windows\\Syswow64\\calc.exe",
                   nullptr, nullptr,
                   FALSE,4,
                   nullptr, nullptr,
                   &startupinfo, &processInformation);
    HANDLE hProcess = processInformation.hProcess;
    if (hProcess == nullptr) {
        printf("Open Process error!");
        return FALSE;
    }

    // prepare for getting PEB
    Q_process NtQueryInformationProcess = NULL;
    PROCESS_BASIC_INFORMATION pbi = {0};
    RTL_USER_PROCESS_PARAMETERS Param = {0};
    USHORT usCmdLen = 0;
    USHORT usPathLen = 0;


    NtQueryInformationProcess = (Q_process) GetProcAddress(LoadLibrary("ntdll.dll"), "NtQueryInformationProcess");
    if (NULL == NtQueryInformationProcess) {
        printf("GetProcAddress Error");
        return FALSE;
    }
    DWORD dwResult;
#if defined(_WIN64)
    WOW64_CONTEXT context = WOW64_CONTEXT();
    context.ContextFlags = CONTEXT_INTEGER;
    dwResult = Wow64GetThreadContext(processInformation.hThread, &context);
#else
    CONTEXT context = CONTEXT();
    context.ContextFlags = CONTEXT_INTEGER;
    dwResult = GetThreadContext(processInformation.hThread, &context);
#endif
    DWORD pebLocation = context.Ebx + 8;
    PEB* peb = 0;
    // get PebBaseAddress in PROCESS_BASIC_INFORMATION of prococess
    if (ReadProcessMemory(hProcess, (LPVOID) pebLocation, &peb, sizeof(DWORD), NULL) == 0) {
        debugBs("ReadProcessmemory");
    }
    // get ProcessParameters in PEB of process
     if (ReadProcessMemory(hProcess, peb->ProcessParameters, &Param, sizeof(Param), NULL) == 0) {
          debugBs("ReadProcessMemory");
      }
    auto *lpwszCmd = (wchar_t *) L"C:\\Windows\\Syswow64\\cmd.exe";
    auto *lpwszPath = (wchar_t *) L"C:\\Windows\\Syswow64\\cmd.exe";
    // modify cmdline data
    usCmdLen = 2 + 2 * wcslen(lpwszCmd); // cal lenth of unicode str
    if (WriteProcessMemory(hProcess, Param.CommandLine.Buffer, lpwszCmd, usCmdLen, NULL) == 0) {
        debugBs("WriteProcessMemory");
    }
    if (WriteProcessMemory(hProcess, &Param.CommandLine.Length, &usCmdLen, sizeof(usCmdLen), NULL) == 0) {
        debugBs("WriteProcessMemory");
    }
    // modify path data
    usPathLen = 2 + 2 * wcslen(lpwszPath); // cal lenth of unicode str
    if (WriteProcessMemory(hProcess, Param.ImagePathName.Buffer, lpwszPath, usPathLen, NULL) == 0) {
        debugBs("WriteProcessMemory");
    }
    if (WriteProcessMemory(hProcess, &Param.ImagePathName.Length, &usPathLen, sizeof(usPathLen), NULL) == 0) {
        debugBs("WriteProcessMemory");
    }
}